<?php

/**
 * ShipmentProcessingApi
 * PHP version 8.3.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */

/**
 * The Selling Partner API for Amazon External Fulfillment Shipments Processing.
 *
 * You can use the External Fulfillment Shipments API to retrieve, manage, and track shipments processed through Amazon's external fulfillment network. Use this API to get shipment details, monitor status changes, and access fulfillment requirements.
 *
 * The version of the OpenAPI document: 2024-09-11
 * Contact: marketplaceapitest@amazon.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SpApi\Api\externalFulfillment\shipments\v2024_09_11;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use SpApi\ApiException;
use SpApi\AuthAndAuth\RestrictedDataTokenSigner;
use SpApi\Configuration;
use SpApi\HeaderSelector;
use SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse;
use SpApi\Model\externalFulfillment\shipments\v2024_09_11\Package;
use SpApi\Model\externalFulfillment\shipments\v2024_09_11\PackageDeliveryStatus;
use SpApi\Model\externalFulfillment\shipments\v2024_09_11\Packages;
use SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShipLabelsInput;
use SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShipLabelsResponse;
use SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShipmentAcknowledgementRequest;
use SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShippingOptionsResponse;
use SpApi\ObjectSerializer;
use Symfony\Component\RateLimiter\LimiterInterface;
use Symfony\Component\RateLimiter\RateLimiterFactory;
use Symfony\Component\RateLimiter\Storage\InMemoryStorage;

/**
 * ShipmentProcessingApi Class Doc Comment.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */
class ShipmentProcessingApi
{
    public ?LimiterInterface $createPackagesRateLimiter;
    public ?LimiterInterface $generateInvoiceRateLimiter;
    public ?LimiterInterface $generateShipLabelsRateLimiter;
    public ?LimiterInterface $processShipmentRateLimiter;
    public ?LimiterInterface $retrieveInvoiceRateLimiter;
    public ?LimiterInterface $retrieveShippingOptionsRateLimiter;
    public ?LimiterInterface $updatePackageRateLimiter;
    public ?LimiterInterface $updatePackageStatusRateLimiter;
    protected ClientInterface $client;

    protected Configuration $config;

    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    private bool $rateLimiterEnabled;
    private InMemoryStorage $rateLimitStorage;

    /**
     * @param int $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config,
        ?ClientInterface $client = null,
        ?bool $rateLimiterEnabled = true,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->config = $config;
        $this->rateLimiterEnabled = $rateLimiterEnabled;

        if ($rateLimiterEnabled) {
            $this->rateLimitStorage = new InMemoryStorage();

            $factory = new RateLimiterFactory(Configuration::getRateLimitOptions('ShipmentProcessingApi-createPackages'), $this->rateLimitStorage);
            $this->createPackagesRateLimiter = $factory->create('ShipmentProcessingApi-createPackages');
            $factory = new RateLimiterFactory(Configuration::getRateLimitOptions('ShipmentProcessingApi-generateInvoice'), $this->rateLimitStorage);
            $this->generateInvoiceRateLimiter = $factory->create('ShipmentProcessingApi-generateInvoice');
            $factory = new RateLimiterFactory(Configuration::getRateLimitOptions('ShipmentProcessingApi-generateShipLabels'), $this->rateLimitStorage);
            $this->generateShipLabelsRateLimiter = $factory->create('ShipmentProcessingApi-generateShipLabels');
            $factory = new RateLimiterFactory(Configuration::getRateLimitOptions('ShipmentProcessingApi-processShipment'), $this->rateLimitStorage);
            $this->processShipmentRateLimiter = $factory->create('ShipmentProcessingApi-processShipment');
            $factory = new RateLimiterFactory(Configuration::getRateLimitOptions('ShipmentProcessingApi-retrieveInvoice'), $this->rateLimitStorage);
            $this->retrieveInvoiceRateLimiter = $factory->create('ShipmentProcessingApi-retrieveInvoice');
            $factory = new RateLimiterFactory(Configuration::getRateLimitOptions('ShipmentProcessingApi-retrieveShippingOptions'), $this->rateLimitStorage);
            $this->retrieveShippingOptionsRateLimiter = $factory->create('ShipmentProcessingApi-retrieveShippingOptions');
            $factory = new RateLimiterFactory(Configuration::getRateLimitOptions('ShipmentProcessingApi-updatePackage'), $this->rateLimitStorage);
            $this->updatePackageRateLimiter = $factory->create('ShipmentProcessingApi-updatePackage');
            $factory = new RateLimiterFactory(Configuration::getRateLimitOptions('ShipmentProcessingApi-updatePackageStatus'), $this->rateLimitStorage);
            $this->updatePackageStatusRateLimiter = $factory->create('ShipmentProcessingApi-updatePackageStatus');
        }

        $this->client = $client ?: new Client();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index.
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index.
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation createPackages.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment. (required)
     * @param Packages    $body
     *                                         A list of packages in the shipment. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function createPackages(
        string $shipment_id,
        Packages $body,
        ?string $restrictedDataToken = null
    ): void {
        $this->createPackagesWithHttpInfo($shipment_id, $body, $restrictedDataToken);
    }

    /**
     * Operation createPackagesWithHttpInfo.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment. (required)
     * @param Packages    $body
     *                                         A list of packages in the shipment. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @return array of , HTTP status code, HTTP response headers (array of strings)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function createPackagesWithHttpInfo(
        string $shipment_id,
        Packages $body,
        ?string $restrictedDataToken = null
    ): array {
        $request = $this->createPackagesRequest($shipment_id, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-createPackages');
        } else {
            $request = $this->config->sign($request);
        }

        try {
            $options = $this->createHttpClientOption();

            try {
                if ($this->rateLimiterEnabled) {
                    $this->createPackagesRateLimiter->consume()->ensureAccepted();
                }
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getResponse()->getBody()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            $data = ObjectSerializer::deserialize(
                $e->getResponseBody(),
                '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ErrorList',
                $e->getResponseHeaders()
            );
            $e->setResponseObject($data);

            throw $e;
        }
    }

    /**
     * Operation createPackagesAsync.
     *
     * @param string   $shipment_id
     *                              The ID of the shipment. (required)
     * @param Packages $body
     *                              A list of packages in the shipment. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function createPackagesAsync(
        string $shipment_id,
        Packages $body
    ): PromiseInterface {
        return $this->createPackagesAsyncWithHttpInfo($shipment_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            )
        ;
    }

    /**
     * Operation createPackagesAsyncWithHttpInfo.
     *
     * @param string   $shipment_id
     *                              The ID of the shipment. (required)
     * @param Packages $body
     *                              A list of packages in the shipment. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function createPackagesAsyncWithHttpInfo(
        string $shipment_id,
        Packages $body,
        ?string $restrictedDataToken = null
    ): PromiseInterface {
        $returnType = '';
        $request = $this->createPackagesRequest($shipment_id, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-createPackages');
        } else {
            $request = $this->config->sign($request);
        }
        if ($this->rateLimiterEnabled) {
            $this->createPackagesRateLimiter->consume()->ensureAccepted();
        }

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            )
        ;
    }

    /**
     * Create request for operation 'createPackages'.
     *
     * @param string   $shipment_id
     *                              The ID of the shipment. (required)
     * @param Packages $body
     *                              A list of packages in the shipment. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function createPackagesRequest(
        string $shipment_id,
        Packages $body
    ): Request {
        // verify the required parameter 'shipment_id' is set
        if (null === $shipment_id || (is_array($shipment_id) && 0 === count($shipment_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling createPackages'
            );
        }
        // verify the required parameter 'body' is set
        if (null === $body || (is_array($body) && 0 === count($body))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createPackages'
            );
        }

        $resourcePath = '/externalFulfillment/2024-09-11/shipments/{shipmentId}/packages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $shipment_id) {
            $resourcePath = str_replace(
                '{shipmentId}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            'application/json',
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams, $this->config);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateInvoice.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment whose invoice you want. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function generateInvoice(
        string $shipment_id,
        ?string $restrictedDataToken = null
    ): InvoiceResponse {
        list($response) = $this->generateInvoiceWithHttpInfo($shipment_id, $restrictedDataToken);

        return $response;
    }

    /**
     * Operation generateInvoiceWithHttpInfo.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment whose invoice you want. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @return array of \SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function generateInvoiceWithHttpInfo(
        string $shipment_id,
        ?string $restrictedDataToken = null
    ): array {
        $request = $this->generateInvoiceRequest($shipment_id);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-generateInvoice');
        } else {
            $request = $this->config->sign($request);
        }

        try {
            $options = $this->createHttpClientOption();

            try {
                if ($this->rateLimiterEnabled) {
                    $this->generateInvoiceRateLimiter->consume()->ensureAccepted();
                }
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getResponse()->getBody()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            if ('\SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse' === '\SplFileObject') {
                $content = $response->getBody(); // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('\SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse' !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse', []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            $data = ObjectSerializer::deserialize(
                $e->getResponseBody(),
                '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ErrorList',
                $e->getResponseHeaders()
            );
            $e->setResponseObject($data);

            throw $e;
        }
    }

    /**
     * Operation generateInvoiceAsync.
     *
     * @param string $shipment_id
     *                            The ID of the shipment whose invoice you want. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function generateInvoiceAsync(
        string $shipment_id
    ): PromiseInterface {
        return $this->generateInvoiceAsyncWithHttpInfo($shipment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            )
        ;
    }

    /**
     * Operation generateInvoiceAsyncWithHttpInfo.
     *
     * @param string $shipment_id
     *                            The ID of the shipment whose invoice you want. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function generateInvoiceAsyncWithHttpInfo(
        string $shipment_id,
        ?string $restrictedDataToken = null
    ): PromiseInterface {
        $returnType = '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse';
        $request = $this->generateInvoiceRequest($shipment_id);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-generateInvoice');
        } else {
            $request = $this->config->sign($request);
        }
        if ($this->rateLimiterEnabled) {
            $this->generateInvoiceRateLimiter->consume()->ensureAccepted();
        }

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ('\SplFileObject' === $returnType) {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== $returnType) {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            )
        ;
    }

    /**
     * Create request for operation 'generateInvoice'.
     *
     * @param string $shipment_id
     *                            The ID of the shipment whose invoice you want. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function generateInvoiceRequest(
        string $shipment_id
    ): Request {
        // verify the required parameter 'shipment_id' is set
        if (null === $shipment_id || (is_array($shipment_id) && 0 === count($shipment_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling generateInvoice'
            );
        }

        $resourcePath = '/externalFulfillment/2024-09-11/shipments/{shipmentId}/invoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $shipment_id) {
            $resourcePath = str_replace(
                '{shipmentId}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams, $this->config);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateShipLabels.
     *
     * @param string               $shipment_id
     *                                                  The ID of the shipment whose shipping labels you want to generate and retrieve. (required)
     * @param string               $operation
     *                                                  Specify whether you want to generate or regenerate a label. (required)
     * @param null|string          $shipping_option_id
     *                                                  The ID of the shipping option whose shipping labels you want. (optional)
     * @param null|ShipLabelsInput $body
     *                                                  Shipping details for when shipping is not done by the marketplace channel. (optional)
     * @param null|string          $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function generateShipLabels(
        string $shipment_id,
        string $operation,
        ?string $shipping_option_id = null,
        ?ShipLabelsInput $body = null,
        ?string $restrictedDataToken = null
    ): ShipLabelsResponse {
        list($response) = $this->generateShipLabelsWithHttpInfo($shipment_id, $operation, $shipping_option_id, $body, $restrictedDataToken);

        return $response;
    }

    /**
     * Operation generateShipLabelsWithHttpInfo.
     *
     * @param string               $shipment_id
     *                                                  The ID of the shipment whose shipping labels you want to generate and retrieve. (required)
     * @param string               $operation
     *                                                  Specify whether you want to generate or regenerate a label. (required)
     * @param null|string          $shipping_option_id
     *                                                  The ID of the shipping option whose shipping labels you want. (optional)
     * @param null|ShipLabelsInput $body
     *                                                  Shipping details for when shipping is not done by the marketplace channel. (optional)
     * @param null|string          $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @return array of \SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShipLabelsResponse, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function generateShipLabelsWithHttpInfo(
        string $shipment_id,
        string $operation,
        ?string $shipping_option_id = null,
        ?ShipLabelsInput $body = null,
        ?string $restrictedDataToken = null
    ): array {
        $request = $this->generateShipLabelsRequest($shipment_id, $operation, $shipping_option_id, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-generateShipLabels');
        } else {
            $request = $this->config->sign($request);
        }

        try {
            $options = $this->createHttpClientOption();

            try {
                if ($this->rateLimiterEnabled) {
                    $this->generateShipLabelsRateLimiter->consume()->ensureAccepted();
                }
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getResponse()->getBody()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            if ('\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShipLabelsResponse' === '\SplFileObject') {
                $content = $response->getBody(); // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShipLabelsResponse' !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShipLabelsResponse', []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            $data = ObjectSerializer::deserialize(
                $e->getResponseBody(),
                '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ErrorList',
                $e->getResponseHeaders()
            );
            $e->setResponseObject($data);

            throw $e;
        }
    }

    /**
     * Operation generateShipLabelsAsync.
     *
     * @param string               $shipment_id
     *                                                 The ID of the shipment whose shipping labels you want to generate and retrieve. (required)
     * @param string               $operation
     *                                                 Specify whether you want to generate or regenerate a label. (required)
     * @param null|string          $shipping_option_id
     *                                                 The ID of the shipping option whose shipping labels you want. (optional)
     * @param null|ShipLabelsInput $body
     *                                                 Shipping details for when shipping is not done by the marketplace channel. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function generateShipLabelsAsync(
        string $shipment_id,
        string $operation,
        ?string $shipping_option_id = null,
        ?ShipLabelsInput $body = null
    ): PromiseInterface {
        return $this->generateShipLabelsAsyncWithHttpInfo($shipment_id, $operation, $shipping_option_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            )
        ;
    }

    /**
     * Operation generateShipLabelsAsyncWithHttpInfo.
     *
     * @param string               $shipment_id
     *                                                 The ID of the shipment whose shipping labels you want to generate and retrieve. (required)
     * @param string               $operation
     *                                                 Specify whether you want to generate or regenerate a label. (required)
     * @param null|string          $shipping_option_id
     *                                                 The ID of the shipping option whose shipping labels you want. (optional)
     * @param null|ShipLabelsInput $body
     *                                                 Shipping details for when shipping is not done by the marketplace channel. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function generateShipLabelsAsyncWithHttpInfo(
        string $shipment_id,
        string $operation,
        ?string $shipping_option_id = null,
        ?ShipLabelsInput $body = null,
        ?string $restrictedDataToken = null
    ): PromiseInterface {
        $returnType = '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShipLabelsResponse';
        $request = $this->generateShipLabelsRequest($shipment_id, $operation, $shipping_option_id, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-generateShipLabels');
        } else {
            $request = $this->config->sign($request);
        }
        if ($this->rateLimiterEnabled) {
            $this->generateShipLabelsRateLimiter->consume()->ensureAccepted();
        }

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ('\SplFileObject' === $returnType) {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== $returnType) {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            )
        ;
    }

    /**
     * Create request for operation 'generateShipLabels'.
     *
     * @param string               $shipment_id
     *                                                 The ID of the shipment whose shipping labels you want to generate and retrieve. (required)
     * @param string               $operation
     *                                                 Specify whether you want to generate or regenerate a label. (required)
     * @param null|string          $shipping_option_id
     *                                                 The ID of the shipping option whose shipping labels you want. (optional)
     * @param null|ShipLabelsInput $body
     *                                                 Shipping details for when shipping is not done by the marketplace channel. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function generateShipLabelsRequest(
        string $shipment_id,
        string $operation,
        ?string $shipping_option_id = null,
        ?ShipLabelsInput $body = null
    ): Request {
        // verify the required parameter 'shipment_id' is set
        if (null === $shipment_id || (is_array($shipment_id) && 0 === count($shipment_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling generateShipLabels'
            );
        }
        // verify the required parameter 'operation' is set
        if (null === $operation || (is_array($operation) && 0 === count($operation))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $operation when calling generateShipLabels'
            );
        }

        $resourcePath = '/externalFulfillment/2024-09-11/shipments/{shipmentId}/shipLabels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shipping_option_id,
            'shippingOptionId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false, // required
            $this->config
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $operation,
            'operation', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true, // required
            $this->config
        ) ?? []);

        // path params
        if (null !== $shipment_id) {
            $resourcePath = str_replace(
                '{shipmentId}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            'application/json',
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams, $this->config);

        return new Request(
            'PUT',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation processShipment.
     *
     * @param string                              $shipment_id
     *                                                                 The ID of the shipment you want to confirm or reject. (required)
     * @param string                              $operation
     *                                                                 The status of the shipment. (required)
     * @param null|ShipmentAcknowledgementRequest $body
     *                                                                 Information about the shipment and its line items. (optional)
     * @param null|string                         $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function processShipment(
        string $shipment_id,
        string $operation,
        ?ShipmentAcknowledgementRequest $body = null,
        ?string $restrictedDataToken = null
    ): void {
        $this->processShipmentWithHttpInfo($shipment_id, $operation, $body, $restrictedDataToken);
    }

    /**
     * Operation processShipmentWithHttpInfo.
     *
     * @param string                              $shipment_id
     *                                                                 The ID of the shipment you want to confirm or reject. (required)
     * @param string                              $operation
     *                                                                 The status of the shipment. (required)
     * @param null|ShipmentAcknowledgementRequest $body
     *                                                                 Information about the shipment and its line items. (optional)
     * @param null|string                         $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @return array of , HTTP status code, HTTP response headers (array of strings)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function processShipmentWithHttpInfo(
        string $shipment_id,
        string $operation,
        ?ShipmentAcknowledgementRequest $body = null,
        ?string $restrictedDataToken = null
    ): array {
        $request = $this->processShipmentRequest($shipment_id, $operation, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-processShipment');
        } else {
            $request = $this->config->sign($request);
        }

        try {
            $options = $this->createHttpClientOption();

            try {
                if ($this->rateLimiterEnabled) {
                    $this->processShipmentRateLimiter->consume()->ensureAccepted();
                }
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getResponse()->getBody()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            $data = ObjectSerializer::deserialize(
                $e->getResponseBody(),
                '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ErrorList',
                $e->getResponseHeaders()
            );
            $e->setResponseObject($data);

            throw $e;
        }
    }

    /**
     * Operation processShipmentAsync.
     *
     * @param string                              $shipment_id
     *                                                         The ID of the shipment you want to confirm or reject. (required)
     * @param string                              $operation
     *                                                         The status of the shipment. (required)
     * @param null|ShipmentAcknowledgementRequest $body
     *                                                         Information about the shipment and its line items. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function processShipmentAsync(
        string $shipment_id,
        string $operation,
        ?ShipmentAcknowledgementRequest $body = null
    ): PromiseInterface {
        return $this->processShipmentAsyncWithHttpInfo($shipment_id, $operation, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            )
        ;
    }

    /**
     * Operation processShipmentAsyncWithHttpInfo.
     *
     * @param string                              $shipment_id
     *                                                         The ID of the shipment you want to confirm or reject. (required)
     * @param string                              $operation
     *                                                         The status of the shipment. (required)
     * @param null|ShipmentAcknowledgementRequest $body
     *                                                         Information about the shipment and its line items. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function processShipmentAsyncWithHttpInfo(
        string $shipment_id,
        string $operation,
        ?ShipmentAcknowledgementRequest $body = null,
        ?string $restrictedDataToken = null
    ): PromiseInterface {
        $returnType = '';
        $request = $this->processShipmentRequest($shipment_id, $operation, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-processShipment');
        } else {
            $request = $this->config->sign($request);
        }
        if ($this->rateLimiterEnabled) {
            $this->processShipmentRateLimiter->consume()->ensureAccepted();
        }

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            )
        ;
    }

    /**
     * Create request for operation 'processShipment'.
     *
     * @param string                              $shipment_id
     *                                                         The ID of the shipment you want to confirm or reject. (required)
     * @param string                              $operation
     *                                                         The status of the shipment. (required)
     * @param null|ShipmentAcknowledgementRequest $body
     *                                                         Information about the shipment and its line items. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function processShipmentRequest(
        string $shipment_id,
        string $operation,
        ?ShipmentAcknowledgementRequest $body = null
    ): Request {
        // verify the required parameter 'shipment_id' is set
        if (null === $shipment_id || (is_array($shipment_id) && 0 === count($shipment_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling processShipment'
            );
        }
        // verify the required parameter 'operation' is set
        if (null === $operation || (is_array($operation) && 0 === count($operation))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $operation when calling processShipment'
            );
        }

        $resourcePath = '/externalFulfillment/2024-09-11/shipments/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $operation,
            'operation', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true, // required
            $this->config
        ) ?? []);

        // path params
        if (null !== $shipment_id) {
            $resourcePath = str_replace(
                '{shipmentId}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            'application/json',
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams, $this->config);

        return new Request(
            'POST',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveInvoice.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment whose invoice you want to retrieve. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function retrieveInvoice(
        string $shipment_id,
        ?string $restrictedDataToken = null
    ): InvoiceResponse {
        list($response) = $this->retrieveInvoiceWithHttpInfo($shipment_id, $restrictedDataToken);

        return $response;
    }

    /**
     * Operation retrieveInvoiceWithHttpInfo.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment whose invoice you want to retrieve. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @return array of \SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function retrieveInvoiceWithHttpInfo(
        string $shipment_id,
        ?string $restrictedDataToken = null
    ): array {
        $request = $this->retrieveInvoiceRequest($shipment_id);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-retrieveInvoice');
        } else {
            $request = $this->config->sign($request);
        }

        try {
            $options = $this->createHttpClientOption();

            try {
                if ($this->rateLimiterEnabled) {
                    $this->retrieveInvoiceRateLimiter->consume()->ensureAccepted();
                }
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getResponse()->getBody()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            if ('\SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse' === '\SplFileObject') {
                $content = $response->getBody(); // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('\SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse' !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse', []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            $data = ObjectSerializer::deserialize(
                $e->getResponseBody(),
                '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ErrorList',
                $e->getResponseHeaders()
            );
            $e->setResponseObject($data);

            throw $e;
        }
    }

    /**
     * Operation retrieveInvoiceAsync.
     *
     * @param string $shipment_id
     *                            The ID of the shipment whose invoice you want to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveInvoiceAsync(
        string $shipment_id
    ): PromiseInterface {
        return $this->retrieveInvoiceAsyncWithHttpInfo($shipment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            )
        ;
    }

    /**
     * Operation retrieveInvoiceAsyncWithHttpInfo.
     *
     * @param string $shipment_id
     *                            The ID of the shipment whose invoice you want to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveInvoiceAsyncWithHttpInfo(
        string $shipment_id,
        ?string $restrictedDataToken = null
    ): PromiseInterface {
        $returnType = '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\InvoiceResponse';
        $request = $this->retrieveInvoiceRequest($shipment_id);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-retrieveInvoice');
        } else {
            $request = $this->config->sign($request);
        }
        if ($this->rateLimiterEnabled) {
            $this->retrieveInvoiceRateLimiter->consume()->ensureAccepted();
        }

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ('\SplFileObject' === $returnType) {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== $returnType) {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            )
        ;
    }

    /**
     * Create request for operation 'retrieveInvoice'.
     *
     * @param string $shipment_id
     *                            The ID of the shipment whose invoice you want to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveInvoiceRequest(
        string $shipment_id
    ): Request {
        // verify the required parameter 'shipment_id' is set
        if (null === $shipment_id || (is_array($shipment_id) && 0 === count($shipment_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling retrieveInvoice'
            );
        }

        $resourcePath = '/externalFulfillment/2024-09-11/shipments/{shipmentId}/invoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $shipment_id) {
            $resourcePath = str_replace(
                '{shipmentId}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams, $this->config);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveShippingOptions.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment to which the package belongs. (required)
     * @param string      $package_id
     *                                         The ID of the package for which you want to retrieve shipping options. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function retrieveShippingOptions(
        string $shipment_id,
        string $package_id,
        ?string $restrictedDataToken = null
    ): ShippingOptionsResponse {
        list($response) = $this->retrieveShippingOptionsWithHttpInfo($shipment_id, $package_id, $restrictedDataToken);

        return $response;
    }

    /**
     * Operation retrieveShippingOptionsWithHttpInfo.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment to which the package belongs. (required)
     * @param string      $package_id
     *                                         The ID of the package for which you want to retrieve shipping options. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @return array of \SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShippingOptionsResponse, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function retrieveShippingOptionsWithHttpInfo(
        string $shipment_id,
        string $package_id,
        ?string $restrictedDataToken = null
    ): array {
        $request = $this->retrieveShippingOptionsRequest($shipment_id, $package_id);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-retrieveShippingOptions');
        } else {
            $request = $this->config->sign($request);
        }

        try {
            $options = $this->createHttpClientOption();

            try {
                if ($this->rateLimiterEnabled) {
                    $this->retrieveShippingOptionsRateLimiter->consume()->ensureAccepted();
                }
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getResponse()->getBody()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            if ('\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShippingOptionsResponse' === '\SplFileObject') {
                $content = $response->getBody(); // stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ('\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShippingOptionsResponse' !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShippingOptionsResponse', []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            $data = ObjectSerializer::deserialize(
                $e->getResponseBody(),
                '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ErrorList',
                $e->getResponseHeaders()
            );
            $e->setResponseObject($data);

            throw $e;
        }
    }

    /**
     * Operation retrieveShippingOptionsAsync.
     *
     * @param string $shipment_id
     *                            The ID of the shipment to which the package belongs. (required)
     * @param string $package_id
     *                            The ID of the package for which you want to retrieve shipping options. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveShippingOptionsAsync(
        string $shipment_id,
        string $package_id
    ): PromiseInterface {
        return $this->retrieveShippingOptionsAsyncWithHttpInfo($shipment_id, $package_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            )
        ;
    }

    /**
     * Operation retrieveShippingOptionsAsyncWithHttpInfo.
     *
     * @param string $shipment_id
     *                            The ID of the shipment to which the package belongs. (required)
     * @param string $package_id
     *                            The ID of the package for which you want to retrieve shipping options. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveShippingOptionsAsyncWithHttpInfo(
        string $shipment_id,
        string $package_id,
        ?string $restrictedDataToken = null
    ): PromiseInterface {
        $returnType = '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ShippingOptionsResponse';
        $request = $this->retrieveShippingOptionsRequest($shipment_id, $package_id);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-retrieveShippingOptions');
        } else {
            $request = $this->config->sign($request);
        }
        if ($this->rateLimiterEnabled) {
            $this->retrieveShippingOptionsRateLimiter->consume()->ensureAccepted();
        }

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ('\SplFileObject' === $returnType) {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== $returnType) {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            )
        ;
    }

    /**
     * Create request for operation 'retrieveShippingOptions'.
     *
     * @param string $shipment_id
     *                            The ID of the shipment to which the package belongs. (required)
     * @param string $package_id
     *                            The ID of the package for which you want to retrieve shipping options. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function retrieveShippingOptionsRequest(
        string $shipment_id,
        string $package_id
    ): Request {
        // verify the required parameter 'shipment_id' is set
        if (null === $shipment_id || (is_array($shipment_id) && 0 === count($shipment_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling retrieveShippingOptions'
            );
        }
        // verify the required parameter 'package_id' is set
        if (null === $package_id || (is_array($package_id) && 0 === count($package_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $package_id when calling retrieveShippingOptions'
            );
        }

        $resourcePath = '/externalFulfillment/2024-09-11/shipments/{shipmentId}/shippingOptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $package_id,
            'packageId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true, // required
            $this->config
        ) ?? []);

        // path params
        if (null !== $shipment_id) {
            $resourcePath = str_replace(
                '{shipmentId}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams, $this->config);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePackage.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment to which the package belongs. (required)
     * @param string      $package_id
     *                                         The ID of the package whose information you want to update. (required)
     * @param Package     $body
     *                                         The body of the request. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function updatePackage(
        string $shipment_id,
        string $package_id,
        Package $body,
        ?string $restrictedDataToken = null
    ): void {
        $this->updatePackageWithHttpInfo($shipment_id, $package_id, $body, $restrictedDataToken);
    }

    /**
     * Operation updatePackageWithHttpInfo.
     *
     * @param string      $shipment_id
     *                                         The ID of the shipment to which the package belongs. (required)
     * @param string      $package_id
     *                                         The ID of the package whose information you want to update. (required)
     * @param Package     $body
     *                                         The body of the request. (required)
     * @param null|string $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @return array of , HTTP status code, HTTP response headers (array of strings)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function updatePackageWithHttpInfo(
        string $shipment_id,
        string $package_id,
        Package $body,
        ?string $restrictedDataToken = null
    ): array {
        $request = $this->updatePackageRequest($shipment_id, $package_id, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-updatePackage');
        } else {
            $request = $this->config->sign($request);
        }

        try {
            $options = $this->createHttpClientOption();

            try {
                if ($this->rateLimiterEnabled) {
                    $this->updatePackageRateLimiter->consume()->ensureAccepted();
                }
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getResponse()->getBody()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            $data = ObjectSerializer::deserialize(
                $e->getResponseBody(),
                '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ErrorList',
                $e->getResponseHeaders()
            );
            $e->setResponseObject($data);

            throw $e;
        }
    }

    /**
     * Operation updatePackageAsync.
     *
     * @param string  $shipment_id
     *                             The ID of the shipment to which the package belongs. (required)
     * @param string  $package_id
     *                             The ID of the package whose information you want to update. (required)
     * @param Package $body
     *                             The body of the request. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function updatePackageAsync(
        string $shipment_id,
        string $package_id,
        Package $body
    ): PromiseInterface {
        return $this->updatePackageAsyncWithHttpInfo($shipment_id, $package_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            )
        ;
    }

    /**
     * Operation updatePackageAsyncWithHttpInfo.
     *
     * @param string  $shipment_id
     *                             The ID of the shipment to which the package belongs. (required)
     * @param string  $package_id
     *                             The ID of the package whose information you want to update. (required)
     * @param Package $body
     *                             The body of the request. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function updatePackageAsyncWithHttpInfo(
        string $shipment_id,
        string $package_id,
        Package $body,
        ?string $restrictedDataToken = null
    ): PromiseInterface {
        $returnType = '';
        $request = $this->updatePackageRequest($shipment_id, $package_id, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-updatePackage');
        } else {
            $request = $this->config->sign($request);
        }
        if ($this->rateLimiterEnabled) {
            $this->updatePackageRateLimiter->consume()->ensureAccepted();
        }

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            )
        ;
    }

    /**
     * Create request for operation 'updatePackage'.
     *
     * @param string  $shipment_id
     *                             The ID of the shipment to which the package belongs. (required)
     * @param string  $package_id
     *                             The ID of the package whose information you want to update. (required)
     * @param Package $body
     *                             The body of the request. (required)
     *
     * @throws \InvalidArgumentException
     */
    public function updatePackageRequest(
        string $shipment_id,
        string $package_id,
        Package $body
    ): Request {
        // verify the required parameter 'shipment_id' is set
        if (null === $shipment_id || (is_array($shipment_id) && 0 === count($shipment_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling updatePackage'
            );
        }
        // verify the required parameter 'package_id' is set
        if (null === $package_id || (is_array($package_id) && 0 === count($package_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $package_id when calling updatePackage'
            );
        }
        // verify the required parameter 'body' is set
        if (null === $body || (is_array($body) && 0 === count($body))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updatePackage'
            );
        }

        $resourcePath = '/externalFulfillment/2024-09-11/shipments/{shipmentId}/packages/{packageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if (null !== $shipment_id) {
            $resourcePath = str_replace(
                '{shipmentId}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }
        // path params
        if (null !== $package_id) {
            $resourcePath = str_replace(
                '{packageId}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            'application/json',
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams, $this->config);

        return new Request(
            'PUT',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePackageStatus.
     *
     * @param string                     $shipment_id
     *                                                        The ID of the shipment to which the package belongs. (required)
     * @param string                     $package_id
     *                                                        The ID of the package whose status you want to update. (required)
     * @param null|string                $status
     *                                                        **DEPRECATED**. Do not use. Package status is defined in the body parameter. (optional)
     * @param null|PackageDeliveryStatus $body
     *                                                        The body of the request. (optional)
     * @param null|string                $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function updatePackageStatus(
        string $shipment_id,
        string $package_id,
        ?string $status = null,
        ?PackageDeliveryStatus $body = null,
        ?string $restrictedDataToken = null
    ): void {
        $this->updatePackageStatusWithHttpInfo($shipment_id, $package_id, $status, $body, $restrictedDataToken);
    }

    /**
     * Operation updatePackageStatusWithHttpInfo.
     *
     * @param string                     $shipment_id
     *                                                        The ID of the shipment to which the package belongs. (required)
     * @param string                     $package_id
     *                                                        The ID of the package whose status you want to update. (required)
     * @param null|string                $status
     *                                                        **DEPRECATED**. Do not use. Package status is defined in the body parameter. (optional)
     * @param null|PackageDeliveryStatus $body
     *                                                        The body of the request. (optional)
     * @param null|string                $restrictedDataToken Restricted Data Token (RDT) for accessing restricted resources (optional, required for operations that return PII)
     *
     * @return array of , HTTP status code, HTTP response headers (array of strings)
     *
     * @throws ApiException              on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function updatePackageStatusWithHttpInfo(
        string $shipment_id,
        string $package_id,
        ?string $status = null,
        ?PackageDeliveryStatus $body = null,
        ?string $restrictedDataToken = null
    ): array {
        $request = $this->updatePackageStatusRequest($shipment_id, $package_id, $status, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-updatePackageStatus');
        } else {
            $request = $this->config->sign($request);
        }

        try {
            $options = $this->createHttpClientOption();

            try {
                if ($this->rateLimiterEnabled) {
                    $this->updatePackageStatusRateLimiter->consume()->ensureAccepted();
                }
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getResponse()->getBody()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            $data = ObjectSerializer::deserialize(
                $e->getResponseBody(),
                '\SpApi\Model\externalFulfillment\shipments\v2024_09_11\ErrorList',
                $e->getResponseHeaders()
            );
            $e->setResponseObject($data);

            throw $e;
        }
    }

    /**
     * Operation updatePackageStatusAsync.
     *
     * @param string                     $shipment_id
     *                                                The ID of the shipment to which the package belongs. (required)
     * @param string                     $package_id
     *                                                The ID of the package whose status you want to update. (required)
     * @param null|string                $status
     *                                                **DEPRECATED**. Do not use. Package status is defined in the body parameter. (optional)
     * @param null|PackageDeliveryStatus $body
     *                                                The body of the request. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function updatePackageStatusAsync(
        string $shipment_id,
        string $package_id,
        ?string $status = null,
        ?PackageDeliveryStatus $body = null
    ): PromiseInterface {
        return $this->updatePackageStatusAsyncWithHttpInfo($shipment_id, $package_id, $status, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            )
        ;
    }

    /**
     * Operation updatePackageStatusAsyncWithHttpInfo.
     *
     * @param string                     $shipment_id
     *                                                The ID of the shipment to which the package belongs. (required)
     * @param string                     $package_id
     *                                                The ID of the package whose status you want to update. (required)
     * @param null|string                $status
     *                                                **DEPRECATED**. Do not use. Package status is defined in the body parameter. (optional)
     * @param null|PackageDeliveryStatus $body
     *                                                The body of the request. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function updatePackageStatusAsyncWithHttpInfo(
        string $shipment_id,
        string $package_id,
        ?string $status = null,
        ?PackageDeliveryStatus $body = null,
        ?string $restrictedDataToken = null
    ): PromiseInterface {
        $returnType = '';
        $request = $this->updatePackageStatusRequest($shipment_id, $package_id, $status, $body);
        if (null !== $restrictedDataToken) {
            $request = RestrictedDataTokenSigner::sign($request, $restrictedDataToken, 'ShipmentProcessingApi-updatePackageStatus');
        } else {
            $request = $this->config->sign($request);
        }
        if ($this->rateLimiterEnabled) {
            $this->updatePackageStatusRateLimiter->consume()->ensureAccepted();
        }

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            )
        ;
    }

    /**
     * Create request for operation 'updatePackageStatus'.
     *
     * @param string                     $shipment_id
     *                                                The ID of the shipment to which the package belongs. (required)
     * @param string                     $package_id
     *                                                The ID of the package whose status you want to update. (required)
     * @param null|string                $status
     *                                                **DEPRECATED**. Do not use. Package status is defined in the body parameter. (optional)
     * @param null|PackageDeliveryStatus $body
     *                                                The body of the request. (optional)
     *
     * @throws \InvalidArgumentException
     */
    public function updatePackageStatusRequest(
        string $shipment_id,
        string $package_id,
        ?string $status = null,
        ?PackageDeliveryStatus $body = null
    ): Request {
        // verify the required parameter 'shipment_id' is set
        if (null === $shipment_id || (is_array($shipment_id) && 0 === count($shipment_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling updatePackageStatus'
            );
        }
        // verify the required parameter 'package_id' is set
        if (null === $package_id || (is_array($package_id) && 0 === count($package_id))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $package_id when calling updatePackageStatus'
            );
        }

        $resourcePath = '/externalFulfillment/2024-09-11/shipments/{shipmentId}/packages/{packageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false, // required
            $this->config
        ) ?? []);

        // path params
        if (null !== $shipment_id) {
            $resourcePath = str_replace(
                '{shipmentId}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }
        // path params
        if (null !== $package_id) {
            $resourcePath = str_replace(
                '{packageId}',
                ObjectSerializer::toPathValue($package_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            'application/json',
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ('application/json' === $headers['Content-Type']) {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config);
            }
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams, $this->config);

        return new Request(
            'PATCH',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option.
     *
     * @return array of http client options
     *
     * @throws \RuntimeException on file opening failure
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        return $options;
    }
}
