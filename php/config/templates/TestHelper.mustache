<?php

/**
 * TestHelper
 * PHP version 7.4
 *
 * @category Class
 * @package  {{invokerPackage}}\Test
 */
 {{common_header}}
 /**
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */

namespace {{invokerPackage}}\Test;

use OpenAPI\Client\ObjectSerializer;
use ReflectionClass;
use ReflectionNamedType;
use ReflectionException;
use ReflectionMethod;

/**
 * TestHelper
 * A helper class for testing OpenAPI responses.
 *
 * @category Class
 * @package  {{invokerPackage}}
 */
class TestHelper
{
    /**
     * Retrieves the return type information of the getPayload method of the given response.
     *
     * @param object $response The response object to reflect upon.
     * @return array|null Returns an array with the return type name and nullability, or null if not specified.
     * @throws ReflectionException If the reflection fails.
     */
    public static function getReturnTypeInfo(object $response): ?array
    {
        $reflectionClass = new ReflectionClass($response);
        $reflectionMethod = $reflectionClass->getMethod('getPayload');
        $returnType = $reflectionMethod->getReturnType();

        if ($returnType instanceof ReflectionNamedType) {
            return [$returnType->getName(), $returnType->allowsNull()];
        }

        return null;
    }


    /**
     * Maps the attributes of a given instance based on the expected response data.
     *
     * @param object $instance The instance to populate.
     * @param array $expectedData The expected response data as an associative array.
     * @return void
     */
    public static function mapAttributes(object $instance, array $expectedData): void
    {
        foreach ($instance::attributeMap() as $property => $jsonKey) {
            $setterMethod = $instance::setters()[$property] ?? null;
            $type = $instance::openAPITypes()[$property] ?? null;

            if (!isset($expectedData[$jsonKey])) {
                continue;
            }

            try {
                if (class_exists($type) && !is_a($type, \DateTime::class, true)) {
                    self::handleComplexType($instance, $setterMethod, $type, $expectedData[$jsonKey]);
                } elseif (str_ends_with($type, '[]')) {
                    $objectType = substr($type, 0, -strlen('[]'));
                    self::handleComplexType($instance, $setterMethod, $type, $expectedData[$jsonKey]);
                } else {
                    self::handleSimpleType($instance, $setterMethod, $type, $expectedData[$jsonKey]);
                }
            } catch (\Exception $e) {
                echo "Error deserializing property: $property. " . $e->getMessage() . "\n";
            }
        }
    }

    /**
     * Handles mapping for complex types (nested structures or arrays).
     *
     * @param object $instance The parent instance.
     * @param string|null $setterMethod The setter method for the property.
     * @param string $type The type of the property.
     * @param mixed $data The data to map.
     * @return void
     */
    private static function handleComplexType(object $instance, ?string $setterMethod, string $type, mixed $data): void
    {
        if (!is_array($data)) {
            $deserializedValue = ObjectSerializer::deserialize($data, $type);
            $instance->$setterMethod($deserializedValue);
            return;
        }

        if (array_keys($data) === range(0, count($data) - 1)) {
            // When $data is Array
            $nestedInstances = [];
            $listType = substr($type, 0, -2);
            foreach ($data as $itemData) {
                if (class_exists($listType)) {
                    $nestedNodeInstance = new $listType();
                    self::mapAttributes($nestedNodeInstance, $itemData);
                    $nestedInstances[] = $nestedNodeInstance;
                } else {
                    $deserializedValue = ObjectSerializer::deserialize($itemData, $listType);
                    $nestedInstances[] = $deserializedValue;
                }
            }
            $instance->$setterMethod($nestedInstances);
        } else {
            $nestedInstance = new $type();
            self::mapAttributes($nestedInstance, $data);
            $instance->$setterMethod($nestedInstance);
        }
    }

    /**
     * Handles mapping for simple types (primitives or DateTime).
     *
     * @param object $instance The instance to populate.
     * @param string|null $setterMethod The setter method for the property.
     * @param string $type The type of the property.
     * @param mixed $data The data to map.
     * @return void
     */
    private static function handleSimpleType(object $instance, ?string $setterMethod, string $type, $data): void
    {
        ObjectSerializer::setDateTimeFormat('Y-m-d\TH:i:s.v\Z');
        $deserializedValue = ObjectSerializer::deserialize($data, $type);
        $instance->$setterMethod($deserializedValue);
    }

    /**
     * Converts a snake_case string to camelCase or PascalCase.
     *
     * @param string $snakeCase The input string in snake_case format.
     * @param bool $capitalizeFirst If true, returns PascalCase; if false, returns camelCase.
     * @return string The converted string in camelCase or PascalCase format.
     */
    private static function snakeToCamelCase(string $snakeCase, bool $capitalizeFirst = true): string
    {
        // Split the input string by underscores into an array of words
        $words = explode('_', $snakeCase);

        // Capitalize the first letter of each word and join them into a single string
        $camelCase = implode('', array_map('ucfirst', $words));

        // If capitalizeFirst is true, return the string as is, otherwise lowercase the first letter
        return $capitalizeFirst ? $camelCase : lcfirst($camelCase);
    }

    /**
     * Prepares request parameters by mapping the input array to a structured format.
     *
     * @param array $params The parameter definitions, expected to have a getName() and getType() method.
     * @param array|null $requestParameters The raw request data to map.
     * @return array The prepared request parameters.
     */
    private static function prepareRequestParams(array $params, ?array $requestParameters): array
    {
        $requestParams = [];

        foreach ($params as $param) {
            $paramName = $param->getName();

            // Handle special case for 'payload' parameter.
            if ($paramName === 'payload') {
                $typeName = $param->getType()->getName();
                if (class_exists($typeName)) {
                    $requestInstance = new $typeName();
                    if (isset($requestParameters['body'])) {
                        self::mapAttributes($requestInstance, $requestParameters['body']['value'] ?? []);
                    } elseif (!$param->isOptional()) {
                        // Insert Dummy object
                        $openAPITypes = $typeName::openAPITypes();
                        $setters = $typeName::setters();

                        foreach ($openAPITypes as $propertyName => $propertyType) {
                            // Skip if the property is nullable
                            if ($typeName::isNullable($propertyName)) {
                                continue;
                            }

                            // Generate dummy value based on the type
                            $dummyValue = self::getDummyValueForType($propertyType);

                            // Check if a setter exists for the property
                            if (array_key_exists($propertyName, $setters)) {
                                $setterMethod = $setters[$propertyName];
                                if (method_exists($requestInstance, $setterMethod)) {
                                    // Call the setter method with the dummy value
                                    $requestInstance->$setterMethod($dummyValue);
                                }
                            }
                        }
                    }

                    $requestParams['payload'] = $requestInstance;
                }
                continue;
            }

            // Process regular parameters with snake_case to camelCase conversion.
            $value = null;
            foreach ([false, true] as $capitalizeFirst) {
                $camelCaseName = self::snakeToCamelCase($paramName, $capitalizeFirst);
                if (isset($requestParameters[$camelCaseName])) {
                    $subArray = $requestParameters[$camelCaseName];
                    if (is_array($subArray) && isset($subArray['value'])) {
                        $value = $subArray['value'];
                        break;
                    }
                } elseif (!$param->isOptional()) {
                    $typeName = $param->getType()->getName();
                    // Insert Dummy parameter
                    $value = self::getDummyValueForType($typeName);
                }
            }
            $requestParams[$paramName] = $value;
        }

        return $requestParams;
    }

    /**
     * Returns a dummy value based on the given type.
     *
     * @param string $typeName
     * @return mixed
     * @throws ReflectionException
     */
    private static function getDummyValueForType(string $typeName): mixed
    {
        // Handle array and specific object types
        if (str_ends_with($typeName, '[]')) {
            $elementType = substr($typeName, 0, -2);
            return [self::getDummyValueForType($elementType)];
        }

        if (class_exists($typeName)) {
            $reflectionClass = new ReflectionClass($typeName);
            $instance = $reflectionClass->newInstance();
            // Enum
            if (method_exists($instance, 'getAllowableEnumValues')) {
                $allowableValues = $instance::getAllowableEnumValues();
                return reset($allowableValues);
            }
            // Populate object properties recursively
            $openAPITypes = $instance::openAPITypes();
            $setters = $typeName::setters();

            foreach ($openAPITypes as $propertyName => $propertyType) {
                // Skip if the property is nullable
                if ($typeName::isNullable($propertyName)) {
                    continue;
                }

                // Generate dummy value based on the type
                $dummyValue = self::getDummyValueForType($propertyType);

                // Check if a setter exists for the property
                if (array_key_exists($propertyName, $setters)) {
                    $setterMethod = $setters[$propertyName];
                    if (method_exists($instance, $setterMethod)) {
                        // Call the setter method with the dummy value
                        $instance->$setterMethod($dummyValue);
                    }
                }
            }

            return $instance;
        }

        // Handle primitive types
        return match ($typeName) {
            'int' => 0,
            'float' => 0.0,
            'bool' => false,
            'string' => 'test',
            'array' => ["1"],
            default => null,
        };
    }

    /**
     * Extracts response parameters from an expected response array.
     *
     * @param array|null $expectedResponse The expected response data.
     * @return array|null The extracted response parameters or null if input is null.
     */
    public function getResponseParams(?array $expectedResponse): ?array
    {
        if ($expectedResponse === null) {
            return null;
        }

        // Check if the current entry is an array and contains a 'value' key.
        return array_filter($expectedResponse, function ($subArray) {
            return is_array($subArray);
        });
    }

    /**
     * @param $apiInstance
     * @param string $methodName
     * @return ReflectionMethod
     * @throws ReflectionException
     */
    private static function getReflectionMethod($apiInstance, string $methodName): ReflectionMethod
    {
        return new ReflectionMethod($apiInstance, $methodName);
    }

    /**
     * Parses object types and maps their properties to keys in a JSON-like structure.
     *
     * @param array $matches The matches from regex that capture keys.
     * @param array $openAPITypes
     * @param array $attributeMap
     * @param array $map The map where parsed data is stored.
     * @param string $depth The depth of the current nesting.
     * @return array The updated map with parsed data.
     */
    private static function parseObjectTypes(
        array $matches,
        array $openAPITypes,
        array $attributeMap,
        array &$map,
        string $depth
    ): array {
        $lastIndex = null;
        $keyOccurrencesCount = [];
        foreach ($matches as $index => $match) {
            // Skip already processed keys
            if (isset($map[$index])) {
                continue;
            }

            $key = $match[2];
            // Find the property name from the API key
            $propertyName = array_search($key, $attributeMap, true);
            if ($propertyName === false) {
                continue; // Skip if not found
            } else {
                if (isset($keyOccurrencesCount[$key])) {
                    $keyOccurrencesCount[$key]++;
                    if ($keyOccurrencesCount[$key] > $keyOccurrencesCount[$map[$lastIndex][0]]) {
                        // Mark as Object end;
                        if (isset($map[$lastIndex])) {
                            $map[$lastIndex][3] = 'true';
                        }
                    }
                } else {
                    $keyOccurrencesCount[$key] = 1;
                }
            }

            // Get the property type
            $propertyType = $openAPITypes[$propertyName] ?? 'string';
            if (class_exists($propertyType)) {
                $class = new $propertyType();

                if (!method_exists($class, 'openAPITypes')) {
                    self::setKeyMapping($map, $key, $index, 'string', $depth, 'false');
                    $lastIndex = $index;
                    continue;
                }
                // Map object type and recursively parse
                self::setKeyMapping($map, $key, $index, 'object', $depth, 'false');
                self::parseObjectTypes(
                    $matches,
                    $class::openAPITypes(),
                    $class::attributeMap(),
                    $map,
                    '}' . $depth
                );
            } elseif (str_ends_with($propertyType, '[]')) {
                $elementType = substr($propertyType, 0, -2);

                if (class_exists($elementType)) {
                    // Map array type and recursively parse elements
                    self::setKeyMapping($map, $key, $index, 'array', ']' . $depth, 'false');
                    $class = new $elementType();
                    self::parseObjectTypes(
                        $matches,
                        $class::openAPITypes(),
                        $class::attributeMap(),
                        $map,
                        '}]' . $depth
                    );
                } elseif ($elementType === 'string') {
                    self::setKeyMapping($map, $key, $index, 'string_array', ']' . $depth, 'false');
                } else {
                    echo '!!!Complex nested object detected! $elementType = ' . $elementType . PHP_EOL;
                }
            } elseif ($propertyType === 'object') {
                // Handle  request parameter which doesn't have object class with NameSpace
                self::setKeyMapping($map, $key, $index, $propertyType, $depth, 'false');
                $nextKey = $matches[$index + 1][2];
                $nextPropertyName = array_search($nextKey . '-' . $key, $attributeMap, true);
                $nextPropertyType = $openAPITypes[$nextPropertyName] ?? 'string';
                if (class_exists($nextPropertyType)) {
                    $nextClass = new $nextPropertyType();
                    self::setKeyMapping($map, $nextKey, $index + 1, 'object', '}' . $depth, 'false');
                    self::parseObjectTypes(
                        $matches,
                        $nextClass::openAPITypes(),
                        $nextClass::attributeMap(),
                        $map,
                        '}}' . $depth
                    );
                } elseif ($nextPropertyType === 'array') {
                    self::setKeyMapping($map, $nextKey, $index + 1, 'string_array', ']}' . $depth, 'true');
                } else {
                    self::setKeyMapping($map, $nextKey, $index + 1, $nextPropertyType, '}' . $depth, 'true');
                }
            } else {
                // Map basic types
                self::setKeyMapping($map, $key, $index, $propertyType, $depth, 'false');
            }
            $lastIndex = $index;
        }
        // Mark as Object end;
        if (isset($map[$lastIndex])) {
            $map[$lastIndex][3] = 'true';
        }
        return $map;
    }

    /**
     * Maps a key to its type and depth.
     *
     * @param array $map The map to store the key mapping.
     * @param string $key The key to map.
     * @param int $index The index of the key.
     * @param string $propertyType The type of the property.
     * @param string $depth The depth of nesting.
     * @return void The updated map.
     */
    private static function setKeyMapping(
        array &$map,
        string $key,
        int $index,
        string $propertyType,
        string $depth,
        string $isLast
    ): void {
        $map[$index][0] = $key;
        $map[$index][1] = $propertyType;
        $map[$index][2] = $depth;
        $map[$index][3] = $isLast;
    }

    /**
     * Finds the position of the nth occurrence of a substring (needle) within a string (haystack),
     * considering word boundaries to avoid partial matches.
     *
     * This method ensures that the substring is matched as a standalone word
     * by verifying that it is not part of a larger word using word boundary checks.
     *
     * @param string $haystack The string to search within.
     * @param string $needle The substring to search for.
     * @param int $n The occurrence number to find (1-based).
     * @return int|false The position of the nth occurrence of the substring, or false if not found.
     */
    private static function getNthIndex(string $haystack, string $needle, int $n): bool|int
    {
        // Tracks the starting position for each search
        $offset = 0;
        // Counts the occurrences of the substring
        $count = 0;

        while (true) {
            // Search for the next occurrence of the substring starting from the offset
            $position = strpos($haystack, $needle, $offset);
            if ($position === false) {
                // Return false if no more occurrences are found
                return false;
            }

            // Check if the substring is a standalone word using word boundary checks
            $before = $position === 0 || !ctype_alnum($haystack[$position - 1]);
            $after = $position + strlen($needle)
                >= strlen($haystack) || !ctype_alnum($haystack[$position + strlen($needle)]);

            if ($before && $after) {
                // Increment the count if the substring matches as a standalone word
                $count++;
                if ($count === $n) {
                    // Return the position if the nth occurrence is found
                    return $position;
                }
            }

            // Move the offset forward to search for the next occurrence
            $offset = $position + 1;
        }
    }


    /**
     * Converts a Codegen response text into a JSON-formatted string.
     *
     * This function takes a mapping of object types and a response text,
     * then reformats the text to follow JSON structure.
     * It replaces keys and values in the text based on the mapping provided.
     *
     * @param array $objectTypeMap An array where each element is a tuple containing:
     *                             - The key name (string).
     *                             - The type of the value ("object" or "array", or other types for simple values).
     *                             - A suffix string used to determine the boundary of the value.
     * @param string $jsonText The input text to be converted.
     * @return string The JSON-formatted result string.
     */
    private static function convertCodegenResponseTextToJson(array $objectTypeMap, string $jsonText): string
    {
        $resultJson = $jsonText;
        $keyOccurrencesCount = [];

        foreach ($objectTypeMap as $index => $item) {
            $key = $item[0];

            // Track occurrences of the key for redundant keys
            if (isset($keyOccurrencesCount[$key])) {
                $keyOccurrencesCount[$key]++;
            } else {
                $keyOccurrencesCount[$key] = 1;
            }

            // Find the position of the current key
            $keyPosition = self::getNthIndex($resultJson, $key, $keyOccurrencesCount[$key]);
            if ($keyPosition === false) {
                continue;
            }

            if ($item[1] !== 'object' && $item[1] !== 'array') {
                $nextKey = null;

                // Determine the position of the next key
                if (isset($objectTypeMap[$index + 1])) {
                    $nextKey = $objectTypeMap[$index + 1][0] ?? null;
                }

                $objectEndSuffix = '';
                if (!$nextKey) {
                    $objectEndSuffix = $item[2];
                } elseif (strlen($item[2]) > strlen($objectTypeMap[$index + 1][2])) {
                    $objectEndSuffix = substr($item[2], strlen($objectTypeMap[$index + 1][2]));
                } elseif ($item[3] === 'true') {
                    $objectEndSuffix = substr($item[2], 0, 1);
                }

                // Find the position of the next key or the end of the object
                if ($nextKey) {
                    $pattern = sprintf(
                        "/,\\s*[{\\[]*\\s*%s=/",
                        preg_quote($nextKey, '/') // Escape special characters in $nextKey
                    );
                    // Perform the search using preg_match
                    if (preg_match($pattern, $resultJson, $matches, PREG_OFFSET_CAPTURE, $keyPosition)) {
                        $nextKeyPosition = $matches[0][1] - strlen($objectEndSuffix); // Get the position of the match
                    } else {
                        $nextKeyPosition = null; // No match found
                    }
                } else {
                    $nextKeyPosition = strlen($resultJson) - strlen($objectEndSuffix);
                }

                // Extract the value between the current key and the next key
                $valueStart = $keyPosition + strlen($key . '=');
                $valueLength = $nextKeyPosition - $valueStart;
                $value = substr($resultJson, $valueStart, $valueLength);

                // Trim and format the value
                $value = trim($value);
                if ($item[1] === 'string_array') {
                    $value = self::formatStringToJsonArray($value);
                } elseif ($item[1] !== 'bool' && $item[1] !== 'int') {
                    $value = '"' . $value . '"';
                }

                // Replace the key-value pair in the result JSON
                $resultJson = substr_replace(
                    $resultJson,
                    '"' . $key . '"' . ':' . $value,
                    $keyPosition,
                    $valueLength + strlen($key . ':')
                );
            } else {
                // Replace keys of objects or arrays
                $resultJson = substr_replace(
                    $resultJson,
                    '"' . $key . '"' . ':',
                    $keyPosition,
                    strlen($key . ':')
                );
            }
        }
        return $resultJson;
    }

    /**
     * Converts a Codegen-generated response string into a JSON-compatible associative array.
     *
     * <p>This method takes a string response from a Codegen output, processes it to extract
     * key-value pairs, and maps these pairs to a provided model. The result is a JSON-compatible
     * associative array that can be further used or transformed.</p>
     *
     * <p>Special cases include:</p>
     * <ul>
     *   <li>If the response body is '{}', the method returns {@code null}.</li>
     *   <li>HTML entities in the response string are decoded before further processing.</li>
     * </ul>
     *
     * @param string $codegenText
     * @param object|null $model $model An object representing the initial model structure to map the response data.
     * @param array|null $params
     * @return array|null associative array parsed from the Codegen response string, or
     * @see #parseObjectTypes
     * @see #convertCodegenResponseTextToJson
     */
    private static function convertCodegenTextToModelJson(string $codegenText, ?object $model, ?array $params): ?array
    {
        // Insert or Update case should not have Response body
        if ($codegenText === '{}') {
            return null;
        }
        // Decode HTML entities
        $codegenText = html_entity_decode($codegenText);
        // Extract key=value pairs using regex
        preg_match_all('/([{\[,]?)\s*([^=\s]+)=/', $codegenText, $matches, PREG_SET_ORDER);
        // Clean up matches to remove unwanted characters
        foreach ($matches as &$match) {
            if (preg_match('/[{\[]/', $match[2]) && $match[2] !== ',') {
                $match[2] = preg_replace('/[{\[]/', '', $match[2]);
            }
        }
        unset($match);
        $map = [];
        $apiTypeArray = [];
        $attributeMapArray = [];
        if ($params) {
            // Request Json
            foreach ($params as $index => $param) {
                $type = $param->getType();
                $paramName = $param->getName();
                if ($paramName === 'payload') {
                    $typeName = $param->getType()->getName();
                    if (class_exists($typeName)) {
                        $apiTypeArray['body'] = 'object';
                        $attributeMapArray['body'] = 'body';
                        $apiTypeArray['value-body'] = $typeName;
                        $attributeMapArray['value-body'] = 'value-body';
                        $requestInstance = new $typeName();
                        $apiTypeArray = array_merge($apiTypeArray, $requestInstance::openAPITypes());
                        $attributeMapArray = array_merge($attributeMapArray, $requestInstance::attributeMap());
                    }
                } else {
                    foreach ([false, true] as $capitalizeFirst) {
                        $camelCaseName = self::snakeToCamelCase($paramName, $capitalizeFirst);
                        foreach ($matches as $match) {
                            if ($match[2] == $camelCaseName) {
                                $apiTypeArray[$paramName] = 'object';
                                $attributeMapArray[$paramName] = $camelCaseName;
                                $apiTypeArray['value' . '-' . $camelCaseName] = $param->getType()->getName();
                                $attributeMapArray['value' . '-' . $camelCaseName] = 'value' . '-' . $camelCaseName;
                                break;
                            }
                        }
                    }
                }
            }
        } elseif ($model) {
            // Response Json parse
            $apiTypeArray = $model::openAPITypes();
            $attributeMapArray = $model::attributeMap();
        }
        //Convert Test to JsonText
        $objectTypeMap = self::parseObjectTypes(
            $matches,
            $apiTypeArray,
            $attributeMapArray,
            $map,
            '}'
        );
        $codegenText = self::convertCodegenResponseTextToJson($objectTypeMap, $codegenText);
        // Decode the JSON string into an associative array
        return json_decode($codegenText, true);
    }

    /**
     * Formats a string into a JSON-like array representation.
     *
     * This method takes an input string that represents a list of elements
     * (e.g., "item1,item2,item3"), trims the leading "[" if present, splits
     * the string by commas, trims each element, wraps them in double quotes,
     * and returns the resulting JSON-like array string.
     *
     * Example:
     * Input: "item1,item2,item3"
     * Output: ["item1","item2","item3"]
     *
     * @param string $input The input string to format, which may contain a leading "[".
     * @return string A JSON-like array string with elements wrapped in double quotes.
     */
    private static function formatStringToJsonArray(string $input): string
    {
        // Remove the leading `[` from the input string.
        $trimmedInput = ltrim($input, '[');

        // Split the string by `,` to get individual elements as an array.
        $elements = explode(',', $trimmedInput);

        // Trim each element and wrap it in double quotes.
        $quotedElements = array_map(function ($element) {
            // Trim the element and wrap it in double quotes.
            return '"' . trim($element) . '"';
        }, $elements);

        // Join the quoted elements with commas and return them as a JSON-like array string.
        return '[' . implode(',', $quotedElements);
    }

    /**
     * Prepares request parameters for the API call.
     *
     * @param $apiInstance
     * @param string $methodName
     * @param string $requestJson
     * @return array
     * @throws ReflectionException
     */
    public static function prepareRequestParamsFromMethod($apiInstance, string $methodName, string $requestJson): array
    {
        $reflection = self::getReflectionMethod($apiInstance, $methodName);
        $params = $reflection->getParameters();
        $parsedRequest = self::convertCodegenTextToModelJson(rtrim($requestJson, ';'), null, $params);
        return self::prepareRequestParams($params, $parsedRequest);
    }

    /**
     * Prepares the expected response for the API call.
     *
     * @param $apiInstance
     * @param string $methodName
     * @param string $responseJson
     * @return array|null
     * @throws ReflectionException
     */
    public static function prepareExpectedResponse($apiInstance, string $methodName, string $responseJson): ?array
    {
        $reflection = self::getReflectionMethod($apiInstance, $methodName);
        $returnType = $reflection->getReturnType();

        if ($returnType !== null) {
            $className = $returnType->getName();
            if (class_exists($className)) {
                return self::convertCodegenTextToModelJson($responseJson, new $className(), null);
            }
        }
        return null;
    }

    /**
     * Array that defines scopes parameter required for grantless operation such as Notification API
     * @var array|string[]
     */
    private array $scopesRequiredMap = [
        'NotificationsApi' => ['sellingpartnerapi::notifications']
    ];


    /**
     * Get required scopes for a given API.
     *
     * @param string $apiName
     * @return array
     */
    public function getScopesForApi(string $apiName): array
    {
        return $this->scopesRequiredMap[$apiName] ?? [];
    }

    /**
     * Checks if the test case should be skipped.
     *
     * @param string $testCaseName
     * @return bool
     */
    public static function shouldSkipTest(string $testCaseName): bool
    {
        return in_array($testCaseName, TestHelper::$testSkipCasesList);
    }

    /**
     * Array that defines test cases which are shippable for now
     * @var array|string[]
     */
    public static array $testSkipCasesList = [
        // Order API
        // Missing required parameter in Request regulatedOrderVerificationStatus and can not be auto filled
        //Because there is no difference between 200 case.
        'testUpdateVerificationStatus400',
        'testGetOrderRegulatedInfo200', // Getting 403 due to restricted role required
        'testGetOrderRegulatedInfo400',  // Getting 403 due to restricted role required
        // NotificationAPI
        'testCreateDestination200', // Required request body is missing
        'testCreateSubscription200', // Required request body is missing
        'testDeleteDestination200', // Required parameter destinationId is missing
        'testDeleteSubscriptionById200', // Required parameter subscriptionId is missing
        'testGetDestination200', // Required parameter destinationId is missing
        'testGetSubscription200', // Required parameter notificationType is missing
        'testGetSubscriptionById200' // Required parameter subscriptionId is missing
    ];
}
