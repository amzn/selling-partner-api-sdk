/*
 * The Selling Partner API for Amazon External Fulfillment Shipments Processing
 * You can use the External Fulfillment Shipments API to retrieve, manage, and track shipments processed through Amazon's external fulfillment network. Use this API to get shipment details, monitor status changes, and access fulfillment requirements.
 *
 * OpenAPI spec version: 2024-09-11
 * Contact: marketplaceapitest@amazon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package software.amazon.spapi.models.externalfulfillment.shipments.v2024_09_11;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/** A shipment&#x27;s charge with relevant tax information. */
@Schema(description = "A shipment's charge with relevant tax information.")
public class Charge {
    @SerializedName("baseCharge")
    private ChargeBreakup baseCharge = null;

    @SerializedName("taxBreakup")
    private List<Tax> taxBreakup = null;

    /** The type of charge. */
    @JsonAdapter(ChargeTypeEnum.Adapter.class)
    public enum ChargeTypeEnum {
        @SerializedName("PRODUCT")
        PRODUCT("PRODUCT"),
        @SerializedName("SHIPPING")
        SHIPPING("SHIPPING"),
        @SerializedName("GIFT_WRAP")
        GIFT_WRAP("GIFT_WRAP"),
        @SerializedName("TOTAL")
        TOTAL("TOTAL"),
        @SerializedName("OTHER")
        OTHER("OTHER");

        private String value;

        ChargeTypeEnum(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        public static ChargeTypeEnum fromValue(String input) {
            for (ChargeTypeEnum b : ChargeTypeEnum.values()) {
                if (b.value.equals(input)) {
                    return b;
                }
            }
            return null;
        }

        public static class Adapter extends TypeAdapter<ChargeTypeEnum> {
            @Override
            public void write(final JsonWriter jsonWriter, final ChargeTypeEnum enumeration) throws IOException {
                jsonWriter.value(String.valueOf(enumeration.getValue()));
            }

            @Override
            public ChargeTypeEnum read(final JsonReader jsonReader) throws IOException {
                Object value = jsonReader.nextString();
                return ChargeTypeEnum.fromValue((String) (value));
            }
        }
    }

    @SerializedName("chargeType")
    private ChargeTypeEnum chargeType = null;

    @SerializedName("totalCharge")
    private ChargeBreakup totalCharge = null;

    @SerializedName("totalTax")
    private Tax totalTax = null;

    public Charge baseCharge(ChargeBreakup baseCharge) {
        this.baseCharge = baseCharge;
        return this;
    }

    /**
     * Get baseCharge
     *
     * @return baseCharge
     */
    @Schema(required = true, description = "")
    public ChargeBreakup getBaseCharge() {
        return baseCharge;
    }

    public void setBaseCharge(ChargeBreakup baseCharge) {
        this.baseCharge = baseCharge;
    }

    public Charge taxBreakup(List<Tax> taxBreakup) {
        this.taxBreakup = taxBreakup;
        return this;
    }

    public Charge addTaxBreakupItem(Tax taxBreakupItem) {
        if (this.taxBreakup == null) {
            this.taxBreakup = new ArrayList<Tax>();
        }
        this.taxBreakup.add(taxBreakupItem);
        return this;
    }

    /**
     * The tax charge details.
     *
     * @return taxBreakup
     */
    @Schema(description = "The tax charge details.")
    public List<Tax> getTaxBreakup() {
        return taxBreakup;
    }

    public void setTaxBreakup(List<Tax> taxBreakup) {
        this.taxBreakup = taxBreakup;
    }

    public Charge chargeType(ChargeTypeEnum chargeType) {
        this.chargeType = chargeType;
        return this;
    }

    /**
     * The type of charge.
     *
     * @return chargeType
     */
    @Schema(required = true, description = "The type of charge.")
    public ChargeTypeEnum getChargeType() {
        return chargeType;
    }

    public void setChargeType(ChargeTypeEnum chargeType) {
        this.chargeType = chargeType;
    }

    public Charge totalCharge(ChargeBreakup totalCharge) {
        this.totalCharge = totalCharge;
        return this;
    }

    /**
     * Get totalCharge
     *
     * @return totalCharge
     */
    @Schema(required = true, description = "")
    public ChargeBreakup getTotalCharge() {
        return totalCharge;
    }

    public void setTotalCharge(ChargeBreakup totalCharge) {
        this.totalCharge = totalCharge;
    }

    public Charge totalTax(Tax totalTax) {
        this.totalTax = totalTax;
        return this;
    }

    /**
     * Get totalTax
     *
     * @return totalTax
     */
    @Schema(required = true, description = "")
    public Tax getTotalTax() {
        return totalTax;
    }

    public void setTotalTax(Tax totalTax) {
        this.totalTax = totalTax;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Charge charge = (Charge) o;
        return Objects.equals(this.baseCharge, charge.baseCharge)
                && Objects.equals(this.taxBreakup, charge.taxBreakup)
                && Objects.equals(this.chargeType, charge.chargeType)
                && Objects.equals(this.totalCharge, charge.totalCharge)
                && Objects.equals(this.totalTax, charge.totalTax);
    }

    @Override
    public int hashCode() {
        return Objects.hash(baseCharge, taxBreakup, chargeType, totalCharge, totalTax);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class Charge {\n");

        sb.append("    baseCharge: ").append(toIndentedString(baseCharge)).append("\n");
        sb.append("    taxBreakup: ").append(toIndentedString(taxBreakup)).append("\n");
        sb.append("    chargeType: ").append(toIndentedString(chargeType)).append("\n");
        sb.append("    totalCharge: ").append(toIndentedString(totalCharge)).append("\n");
        sb.append("    totalTax: ").append(toIndentedString(totalTax)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /** Convert the given object to string with each line indented by 4 spaces (except the first line). */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}
